(def runtime-spec-version 100)
(def transaction-version 1)
(def sudo-index 7)
(def sudo-call 0)
(def protos-index 11)
(def add-upload-auth-index 0)
(def upload-index 2)
(def patch-index 3)
(def detach-index 6)

(defloop wait-port
  (Setup
   100 >= .tries)
  (Maybe (->
          {"id" 1 "jsonrpc" "2.0" "method" "chain_getBlockHash" "params" [0]} (ToJson) (Http.Post .rpc-server)
          (FromJson) (ExpectTable) (Take "result") (ExpectString) (Log)
          (Stop))
         (->
          (Math.Dec .tries)
          (Pause 2.0)))
  .tries (Assert.IsNot 0)
  (Log "Waiting for port"))

(defchain make-calldata
  (| (Take 0) (ExpectInt) = .pallet-idx)
  (| (Take 1) (ExpectInt) = .call-idx)
  ; >= copy to allow nesting
  (| (Take 2) (ExpectBytes) >= .args)
  ; call payload to be signed
  ; [module-index call-index] (Check Metadata)
  [.pallet-idx .call-idx] (Substrate.Encode ["u8" "u8"]) >= .call-data
  .args (AppendTo .call-data)
  .call-data)

(defchain send-signed-extrinsic
  (| (Take 0) (ExpectString) = .private-key)
  (| (Take 1) (ExpectBytes) = .call-data)

  ; signer
  .private-key (Sr25519.PublicKey) (Substrate.AccountId) (Log) = .pub-key

  ; multiaddress enum
  [0 .pub-key] (Substrate.Encode ["u8" "a"]) = .signer

  ; account info 
  [.pub-key] (Substrate.Encode ["a"]) (ToHex) = .account-id-hex
  ["System" "Account" .account-id-hex] (Substrate.StorageMap) (ToHex) = .account-info-query
  {"id" 1 "jsonrpc" "2.0" "method" "state_getStorage" "params" [.account-info-query]} (ToJson) (Http.Post .rpc-server)
  (FromJson) (ExpectTable) (Take "result") (ExpectString) (HexToBytes) 
  (Substrate.Decode [Type.Int] ["u32"]) (Take 0) = .nonce

  ; extra data to be signed
  ; [era nonce weight]
  ; use 0 u8 for era to have an immortal transaction
  [0 .nonce 0] (Substrate.Encode ["u8" "c" "c"]) = .extra-data

  ; TODO, this should be a CONSTANT actually
  {"id" 1 "jsonrpc" "2.0" "method" "chain_getBlockHash" "params" [0]} (ToJson) (Http.Post .rpc-server)
  (FromJson) (ExpectTable) (Take "result") (ExpectString) (Log) (HexToBytes) (Log) = .node-genesis-hash

  ; additional data to be signed
  ; [runtime-spec-version transaction-version genesis-hash genesis-or-current-hash]
  [runtime-spec-version transaction-version] (Substrate.Encode ["u32" "u32"]) >= .additional-data
  .node-genesis-hash (AppendTo .additional-data) (AppendTo .additional-data) ; twice

  .call-data >= .signed-payload
  .extra-data (AppendTo .signed-payload)
  .additional-data (AppendTo .signed-payload)
  (Count .signed-payload)
  (If (IsMore 256)
      (-> (Msg "LONG PAYLOAD") .signed-payload (Hash.Blake2-256))
      (-> .signed-payload)) ; use hashed version if longer bigger than 256
  (Sr25519.Sign .private-key) (Log "Signature bytes") >= .signature
  ; add enum index 1
  "0x01" (HexToBytes) (PrependTo .signature)
  .signature (ToHex) (Log "Signature")

  [0x84] (Substrate.Encode ["u8"]) >= .rpc-data
  .signer (AppendTo .rpc-data)
  .signature (AppendTo .rpc-data)
  .extra-data (AppendTo .rpc-data)
  .call-data (AppendTo .rpc-data)
  [.rpc-data] (Substrate.Encode [nil]) (ToHex) (Log "rpc hex") = .rpc-data-hex
  {"id" 1 "jsonrpc" "2.0" "method" "author_submitExtrinsic" "params" [.rpc-data-hex]} (ToJson) (Http.Post .rpc-server)
  (FromJson))

(defchain make-test-asset
  (ToString) (StringToBytes)
  ;; >= .test-asset-n
  ;; "Test Asset " (PrependTo .test-asset-n)
  ;; .test-asset-n (Log "asset content")
  ;; [.test-asset-n] (Substrate.Encode [nil]) >= .test-asset-payload ; name
  ;; "0x00" (HexToBytes) (AppendTo .test-asset-payload) ; 0 len description
  ;; "0x00" (HexToBytes) (AppendTo .test-asset-payload) ; 0 len attributes
  ;; "0x00" (HexToBytes) (AppendTo .test-asset-payload) ; None preview
  ;; ["0"] (Substrate.Encode ["u8"]) (AppendTo .test-asset-payload) ; 0 enum index = Edn
  ;; "(println \"" >= .test-asset-edn
  ;; .test-asset-n (AppendTo .test-asset-edn)
  ;; "\")" (AppendTo .test-asset-edn)
  ;; [.test-asset-edn] (Substrate.Encode [nil]) (AppendTo .test-asset-payload)
  ;; .test-asset-payload
  )

(defchain test-upload-compressing
  (| (Take 0) (ExpectBytes) = .upload-data)
  (| (Take 1) (ExpectInt) = .upload-nonce)
  (| (Take 2) (ExpectInt) = .frag-nonce)

  .upload-data (Brotli.Compress) (| (ToHex) (Log "TEST DATA")) = .immutable

  ; Vec - 0 len
  [0] (Substrate.Encode ["c"]) = .no-refs

  ; Vec - 1 len
  [1] (Substrate.Encode ["c"]) >= .one-tag
  [0] (Substrate.Encode ["u8"]) (AppendTo .one-tag)

  .immutable (Hash.Blake2-256) >= .frag-cid >> .frag-hash-payload = .fragment-hash
  .no-refs >> .frag-hash-payload ; refs
  .one-tag >> .frag-hash-payload ; tags
  "0x00" (HexToBytes) >> .frag-hash-payload ; again no linked asset
  [.frag-nonce] (Substrate.Encode ["u64"]) >> .frag-hash-payload ; NONCE
  [0] (Substrate.Encode ["u32"]) >> .frag-hash-payload ; block
  .frag-hash-payload (Hash.Blake2-256) (ECDSA.Sign "//Alice")
  (| (ToHex) (Log "AUTH SIGNATURE")) >= .payload
  "//Alice" (ECDSA.PublicKey true) (ToHex) (Log "ALICE PUBLIC ECDSA")

  ; block
  [0] (Substrate.Encode ["u32"]) (AppendTo .payload)

  .no-refs (AppendTo .payload) ; refs

  .one-tag (AppendTo .payload) ; tags

  "0x00" (HexToBytes)
  ; Option None - Linked asset
  (AppendTo .payload)
  ; Option None - Include cost
  (AppendTo .payload)

  [.immutable] (Substrate.Encode [nil]) (AppendTo .payload)

  "0x0155a0e40220" (HexToBytes) (PrependTo .frag-cid)
  .frag-cid (ToBase58) >= .frag-cid-str
  "z" (PrependTo .frag-cid-str)
  .frag-cid-str (Log "CID")

  .payload (Log)

  [protos-index upload-index .payload] (Do make-calldata) = .upload-call (| (ToHex) (Log "upload-call"))
  ["//Dave" .upload-call .upload-nonce] (Do send-signed-extrinsic) (Log "upload-call-result")
  [.frag-cid-str .fragment-hash])

(defchain test-patch
  (| (Take 0) (ExpectBytes) = .fragment-hash)
  (| (Take 1) (ExpectInt) = .patch-nonce)
  (| (Take 2) (ExpectInt) = .frag-nonce)

  "0xC0FFEE" (HexToBytes) = .patch-data-bytes
  [.patch-data-bytes] (Substrate.Encode [nil]) >= .patch-data
  "0x01" (HexToBytes) (PrependTo .patch-data)

  .fragment-hash >> .frag-hash-payload
  .patch-data (Hash.Blake2-256) >> .frag-hash-payload ; no data
  [.frag-nonce] (Substrate.Encode ["u64"]) >> .frag-hash-payload ; NONCE
  [0] (Substrate.Encode ["u32"]) >> .frag-hash-payload ; block

  .frag-hash-payload (Hash.Blake2-256) (ECDSA.Sign "//Alice")
  (| (ToHex) (Log "AUTH SIGNATURE")) >= .payload
  "//Alice" (ECDSA.PublicKey true) (ToHex) (Log "ALICE PUBLIC ECDSA")

  ; block
  [0] (Substrate.Encode ["u32"]) (AppendTo .payload)

  .fragment-hash (AppendTo .payload)
  "0x01" (HexToBytes) (AppendTo .payload)
  [123] (Substrate.Encode ["c"]) (AppendTo .payload)
  .patch-data (AppendTo .payload)

  .payload (Log)

  [protos-index patch-index .payload] (Do make-calldata) = .patch-call (| (ToHex) (Log "patch-call"))
  ["//Dave" .patch-call .patch-nonce] (Do send-signed-extrinsic) (Log "patch-call-result"))

(defchain test-detach
  (| (Take 0) (ExpectBytes) >= .detach-payload)
  (| (Take 1) (ExpectInt) = .detach-nonce)

  [2] (Substrate.Encode ["u8"]) (AppendTo .detach-payload)

  [20] (Substrate.Encode ["c"]) (AppendTo .detach-payload)
  "0x90F8bf6A479f320ead074411a4B0e7944Ea8c9C1" (HexToBytes) (AppendTo .detach-payload)

  [protos-index detach-index .detach-payload] (Do make-calldata) = .detach-call (| (ToHex) (Log "detach-call"))
  ["//Dave" .detach-call .detach-nonce] (Do send-signed-extrinsic) (Log "detach-call-result"))

